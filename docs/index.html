<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Storico ESP32 – Grafici (via GitHub Actions)</title>

  <!-- Chart.js & Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root { --bg:#0f1222; --panel:#171a2e; --txt:#e7e9f7; --muted:#95a0c6; --accent:#7aa2ff; }
    * { box-sizing:border-box }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--txt); font:16px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    header{ position:sticky; top:0; z-index:3; background:linear-gradient(180deg, rgba(23,26,46,.98), rgba(23,26,46,.92)); padding:14px 16px; box-shadow:0 2px 10px rgba(0,0,0,.25) }
    header h1{ margin:0; font-size:20px; letter-spacing:.2px }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px }
    .panel{ background:var(--panel); border-radius:16px; padding:16px; box-shadow:0 6px 24px rgba(0,0,0,.25) }
    .controls{ display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center }
    .controls label{ font-size:14px; color:var(--muted); margin-right:6px }
    select, input[type="text"]{ background:#0f1230; color:var(--txt); border:1px solid #2a2f55; border-radius:10px; padding:10px 12px; min-width:160px; outline:none }
    button{ background:var(--accent); color:#0b1022; border:0; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer }
    button[disabled]{ opacity:.6; cursor:not-allowed }
    .src{ margin-left:auto; display:flex; gap:8px; align-items:center; flex:1 1 320px; min-width:260px }
    .src input{ width:100% }
    .row{ margin-top:16px; display:grid; grid-template-columns:1fr; gap:14px }
    @media (min-width:900px){ .row{ grid-template-columns:1fr 1fr 1fr } }
    .card{ background:#0f1230; border:1px solid #2a2f55; border-radius:14px; padding:12px; height:320px }
    .card h3{ margin:0 0 8px; font-size:14px; color:var(--muted); font-weight:600 }
    canvas{ width:100% !important; height:260px !important }
    .foot{ margin-top:18px; color:var(--muted); font-size:13px; display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    a{ color:var(--accent); text-decoration:none }
    .toast{ position:fixed; right:16px; bottom:16px; background:#1b2246; color:var(--txt); border:1px solid #33407a; padding:10px 12px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,.35) }
  </style>
</head>
<body>
<header><div class="wrap"><h1>Storico ESP32 – Grafici (via GitHub Actions)</h1></div></header>

<div class="wrap">
  <div class="panel">
    <div class="controls">
      <div><label for="m1">Metrica 1</label><select id="m1"></select></div>
      <div><label for="m2">Metrica 2</label><select id="m2"></select></div>
      <div><label for="m3">Metrica 3</label><select id="m3"></select></div>

      <div>
        <label for="win">Finestra</label>
        <select id="win">
          <option value="24h">Ultime 24 ore</option>
          <option value="3d">Ultimi 3 giorni</option>
          <option value="7d" selected>Ultimi 7 giorni</option>
          <option value="30d">Ultimi 30 giorni</option>
          <option value="90d">Ultimi 90 giorni</option>
          <option value="all">Tutto</option>
        </select>
      </div>

      <button id="go">Aggiorna</button>

      <div class="src">
        <label for="src">Fonte:</label>
        <input id="src" type="text" spellcheck="false" />
      </div>
    </div>

    <div class="row">
      <div class="card"><h3 id="t1">Grafico 1</h3><canvas id="c1"></canvas></div>
      <div class="card"><h3 id="t2">Grafico 2</h3><canvas id="c2"></canvas></div>
      <div class="card"><h3 id="t3">Grafico 3</h3><canvas id="c3"></canvas></div>
    </div>

    <div class="foot">
      <span>CSV:</span><a id="openCsv" target="_blank" rel="noopener">Apri file</a>
      <span id="count"></span>
      <span id="tsRange"></span>
      <span id="tsLastCsv"></span>
    </div>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>

<script>
  // ===== Config =====
  const CSV_URL_DEFAULT = 'https://raw.githubusercontent.com/samuele9581/esp32-keepalive/main/states/metrics.csv';
  const LS = { url:'hist.url', m1:'hist.m1', m2:'hist.m2', m3:'hist.m3', win:'hist.win' };

  // Etichette più leggibili
  const LABELS = {
    t_air_ds:'T. aria (°C)', t_soil_ds:'T. suolo (°C)',
    sens_suolo_anal1:'Umidità terreno A1 (%)', sens_suolo_anal2:'Umidità terreno A2 (%)',
    soil1:'Umidità terreno 1 (%)', soil2:'Umidità terreno 2 (%)',
    bme_t:'BME Temp (°C)', bme_rh:'BME UR (%)', bme_p:'BME Press (hPa)',
    bme_iaq:'BME IAQ', bme_static_iaq:'BME IAQ statico', bme_iaq_acc:'BME IAQ acc',
    bme_co2eq:'BME CO₂eq (ppm)', bme_voc:'BME VOCeq (ppb)',
    bme_gas_pct:'BME Gas (%)', bme_gas_raw:'BME Gas (Ω)',
    flow_lph:'Flusso (L/h)', flow_total:'Totale (L)',
    vbat:'VBAT (V)', vpv:'VPV (V)', ppv:'Potenza PV (W)',
    rain:'Pioggia', motion:'Movimento', valve1:'Valvola 1', valve2:'Valvola 2'
  };
  const prettyLabel = k => LABELS[k] || k;

  // Colonne che potrebbero essere tempo
  const TIME_CANDS = ['ts','timestamp','time','date','datetime','epoch','epochtime','unix'];

  // Range "ragionevoli" usati SOLO per nascondere punti assurdi della singola metrica (non scartiamo la riga!)
  const RANGES = {
    bme_t:[-20,80], bme_rh:[0,100], bme_p:[850,1100],
    bme_iaq:[0,500], bme_static_iaq:[0,500],
    bme_co2eq:[250,5000], bme_voc:[0,20000], bme_gas_pct:[0,100]
  };
  // Sinonimi per l’applicazione dei range (se nel CSV avessi nomi leggermente diversi)
  const CANON = { iaq:'bme_iaq', static_iaq:'bme_static_iaq', co2eq:'bme_co2eq', co2:'bme_co2eq', voc:'bme_voc', pressure:'bme_p', temp:'bme_t', humidity:'bme_rh' };
  const canon = k => CANON[k] || k;

  // ===== UI refs =====
  const sel1 = document.getElementById('m1');
  const sel2 = document.getElementById('m2');
  const sel3 = document.getElementById('m3');
  const selWin = document.getElementById('win');
  const btnGo = document.getElementById('go');
  const inpSrc = document.getElementById('src');
  const openCsv = document.getElementById('openCsv');
  const t1 = document.getElementById('t1');
  const t2 = document.getElementById('t2');
  const t3 = document.getElementById('t3');
  const countEl = document.getElementById('count');
  const tsRangeEl = document.getElementById('tsRange');
  const tsLastCsvEl = document.getElementById('tsLastCsv');
  const toast = document.getElementById('toast');

  // ===== State =====
  const CH = {};
  let ROWS = [];
  let METRIC_COLS = [];
  let TIME_COL = 'ts';

  // ===== Utils =====
  function showToast(msg){ toast.textContent = msg; toast.style.display='block'; clearTimeout(showToast._t); showToast._t = setTimeout(()=>toast.style.display='none',3200); }
  function setBtnBusy(b){ btnGo.disabled=b; btnGo.textContent = b ? 'Carico…' : 'Aggiorna'; }
  function loadDefaults(){ inpSrc.value = localStorage.getItem(LS.url) || CSV_URL_DEFAULT; selWin.value = localStorage.getItem(LS.win) || '7d'; }
  function savePrefs(){ localStorage.setItem(LS.url, inpSrc.value.trim()); localStorage.setItem(LS.m1, sel1.value||''); localStorage.setItem(LS.m2, sel2.value||''); localStorage.setItem(LS.m3, sel3.value||''); localStorage.setItem(LS.win, selWin.value||'7d'); }

  function toNumber(v){
    if (v===null || v===undefined) return null;
    if (typeof v === 'number') return Number.isFinite(v) ? v : null;
    const s = String(v).trim().replace(',', '.');
    if (s==='' || s.toLowerCase()==='nan') return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function parseEpochMaybe(v){
    const n = toNumber(v);
    if (n==null) return null;
    if (n > 1e12) return n; // ms
    if (n > 1e9) return n*1000; // sec
    if (n > 1e6) return n*1000; // sec short
    return null;
  }

  function detectTimeColumn(fields, sampleRows){
    for (const k of TIME_CANDS) if (fields.includes(k)) return k;
    const check = sampleRows.slice(0,10);
    for (const f of fields){
      let score=0;
      for (const r of check){
        const v = r[f]; if (v==null || v==='') continue;
        const iso = Date.parse(String(v));
        const ep = parseEpochMaybe(v);
        if (Number.isFinite(iso) || Number.isFinite(ep)) score++;
      }
      if (score >= Math.ceil(check.length*0.5)) return f;
    }
    return fields[0]; // fallback: prima colonna
  }

  function normalizeRows(rows, timeField){
    const out=[];
    for (const r of rows){
      let ms = parseEpochMaybe(r[timeField]);
      if (!Number.isFinite(ms)){
        const p = Date.parse(String(r[timeField]));
        if (Number.isFinite(p)) ms=p;
      }
      if (!Number.isFinite(ms)) continue;
      out.push({ ...r, ts: new Date(ms).toISOString() });
    }
    out.sort((a,b)=> Date.parse(a.ts) - Date.parse(b.ts));
    return out;
  }

  function detectNumericColumns(fields, rows, timeField){
    const cols=[];
    for (const f of fields){
      if (f===timeField) continue;
      let seen=0, nums=0;
      for (const r of rows){
        const v = r[f];
        if (v==='' || v==null) continue;
        seen++;
        if (toNumber(v)!=null) nums++;
        if (seen>=40) break;
      }
      if (nums>0 && nums >= Math.max(3, Math.ceil(seen*0.5))) cols.push(f);
    }
    return cols;
  }

  function fmtTsISO(iso){
    try{
      const d=new Date(iso);
      return d.toLocaleString(undefined,{ day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit' });
    }catch{ return iso; }
  }

  // ===== Data fetch =====
  async function fetchCsv(url){
    const u = new URL(url); u.searchParams.set('t', String(Date.now()));
    const res = await fetch(u.toString(), { cache:'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const txt = await res.text();
    return new Promise((resolve,reject)=>{
      Papa.parse(txt, {
        header:true, dynamicTyping:false, skipEmptyLines:true,
        complete: ({data, meta}) => resolve({ rows:data, fields:meta.fields||[] }),
        error: err => reject(err)
      });
    });
  }

  // ===== Charts =====
  function renderChart(id, cfg){
    const el = document.getElementById(id);
    if (!el) return;
    if (CH[id]) { try{ CH[id].destroy(); }catch{} }
    CH[id] = new Chart(el.getContext('2d'), cfg);
    return CH[id];
  }

  function buildLineConfig(labels, values, label){
    return {
      type:'line',
      data:{ labels, datasets:[{ label, data:values, borderWidth:2, pointRadius:0, tension:0.25, spanGaps:true }]},
      options:{
        responsive:true, maintainAspectRatio:false, animation:false,
        interaction:{ mode:'nearest', intersect:false },
        scales:{ x:{ ticks:{ autoSkip:true, maxTicksLimit:8 } }, y:{ beginAtZero:false } },
        plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ title:ctx=>ctx[0]?.label||'', label:ctx=>`${prettyLabel(label)}: ${ctx.parsed.y}` } } }
      }
    };
  }

  function updateTitles(){
    t1.textContent = sel1.value ? prettyLabel(sel1.value) : 'Grafico 1';
    t2.textContent = sel2.value ? prettyLabel(sel2.value) : 'Grafico 2';
    t3.textContent = sel3.value ? prettyLabel(sel3.value) : 'Grafico 3';
  }

  function windowThreshold(id){
    const now = Date.now();
    const map = { '24h':24, '3d':72, '7d':168, '30d':720, '90d':2160 };
    if (id==='all' || !map[id]) return 0;
    return now - map[id]*60*60*1000;
  }

  function valueForPlot(key, raw){
    const v = toNumber(raw);
    if (v==null) return null;
    const c = canon(key);
    const range = RANGES[c];
    if (range && (v<range[0] || v>range[1])) return null; // nascondi punto fuori scala
    return v;
  }

  function fillSelect(sel, keys, prefKey, idx=0){
    sel.innerHTML='';
    keys.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=prettyLabel(k); sel.appendChild(o); });
    const pref = localStorage.getItem(prefKey);
    if (pref && keys.includes(pref)) sel.value=pref;
    else if (keys[idx]) sel.value=keys[idx];
  }

  function populateMetricSelects(){
    fillSelect(sel1, METRIC_COLS, LS.m1, 0);
    fillSelect(sel2, METRIC_COLS, LS.m2, 1);
    fillSelect(sel3, METRIC_COLS, LS.m3, 2);
    updateTitles();
  }

  function filterAndDraw(){
    if (!ROWS.length) return;

    const thr = windowThreshold(selWin.value);
    const vis = (thr>0) ? ROWS.filter(r => Date.parse(r.ts) >= thr) : ROWS;

    const labels = vis.map(r => fmtTsISO(r.ts));
    const drawOne = (sel, canvasId) => {
      const key = sel.value;
      if (!key) return;
      const vals = vis.map(r => valueForPlot(key, r[key]));
      renderChart(canvasId, buildLineConfig(labels, vals, key));
    };

    drawOne(sel1, 'c1'); drawOne(sel2, 'c2'); drawOne(sel3, 'c3');

    countEl.textContent = `• punti visibili: ${vis.length}`;
    if (vis.length){
      tsRangeEl.textContent = `• intervallo: ${fmtTsISO(vis[0].ts)} → ${fmtTsISO(vis[vis.length-1].ts)}`;
    } else { tsRangeEl.textContent = ''; }

    // ultimo nel CSV (indipendente dalla finestra)
    if (ROWS.length){
      tsLastCsvEl.textContent = `• ultimo nel CSV: ${fmtTsISO(ROWS[ROWS.length-1].ts)}`;
    } else { tsLastCsvEl.textContent = ''; }
  }

  async function refreshAll(){
    try{
      setBtnBusy(true);
      savePrefs();
      const url = inpSrc.value.trim();
      openCsv.href = url;

      const { rows, fields } = await fetchCsv(url);
      if (!fields.length) throw new Error('CSV senza header');

      // rileva e normalizza tempo
      TIME_COL = detectTimeColumn(fields, rows);
      const normalized = normalizeRows(rows, TIME_COL);
      if (!normalized.length) throw new Error('Nessuna riga con timestamp valido');

      // colonne numeriche (per i menu)
      METRIC_COLS = detectNumericColumns(fields, normalized, TIME_COL)
        .filter(k => k !== 'ts'); // sicurezza

      ROWS = normalized;

      populateMetricSelects();
      filterAndDraw();
    } catch(e){
      console.error(e);
      showToast('Errore caricamento CSV: ' + (e.message || e));
    } finally {
      setBtnBusy(false);
    }
  }

  // ===== Eventi =====
  document.getElementById('go').addEventListener('click', refreshAll);
  selWin.addEventListener('change', () => { savePrefs(); filterAndDraw(); });
  sel1.addEventListener('change', () => { savePrefs(); updateTitles(); filterAndDraw(); });
  sel2.addEventListener('change', () => { savePrefs(); updateTitles(); filterAndDraw(); });
  sel3.addEventListener('change', () => { savePrefs(); updateTitles(); filterAndDraw(); });
  document.getElementById('src').addEventListener('change', () => { savePrefs(); });

  // Avvio
  loadDefaults();
  openCsv.href = inpSrc.value.trim();
  refreshAll();
</script>
</body>
</html>
	
